# -*- coding: utf-8 -*-
"""Amin Data Science final project-SP1 Binding site Prediction.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1-zN7SsyuIAiHY42Kxd_B0EOHglrGmhXX

# **DATA SCIENCE**
**Project Titel : SP1 Transcription Factor DNA Binding Site Prediction**

Amin Sharifi' s Final Project



Mentor : Shabnam Sadeghi

**Introduction:**
Transcription Factors are proteins that bind to specific sequence motifs on the DNA in order to regulate DNA activity. SP1 transcription factor binds to GC (Nucleobase: Building blocks of DNA) rich motifs.

**Question:**
Given the input data, is it possible to predict the nucleotide sequences as SP1 factor binding/non-binding site based on the presence/absence of motifs present in nucleotides ?
"""

#Importing the essential libraries
import pandas as pd
import numpy as np

#Importing the dataset
df = pd.read_csv('Raw_data.csv')

#PART 1: Exploring the Data

#Checking the head of the dataset
df.head()

#Checking the shape of the data
df.shape

#Checking the characteristics of the data frame and null values
df.info()

#Check if the dataset is balanced
df.value_counts('label')
df['label'].value_counts().sort_index().plot.bar()

#Check if all the sequences have length of 14
seqLen =[len(s) for s in df['sequence']]
set(seqLen)

#PART 2: Create N-Gram(Fragmentize the sequence to characters with length of N) from the DNA sequences in order to prepare the data set for modeling
#Here we use Bag of Words model using count vectorizer

#Import the library
from sklearn.feature_extraction.text import CountVectorizer
seq_texts = df['sequence']

#Create 2-5 mers from the Sequences
cv = CountVectorizer(analyzer='char',ngram_range=(2,5),min_df=0.10,max_df=0.8)
X = cv.fit_transform(seq_texts)

print(X.shape)
X

#Transform output (label) to a binary output
df[ "label_binary" ] = df[ "label" ].map({ 'binding site' : 1,'non-binding site' : 0 } )
y = df[ "label_binary"]#Checking the label type after converting to binary value

df.dtypes

#Sequences are converted to vecotrs, which consist of number of occurence for each 2-5-mers
#Check how the vectors look like
X_array = X.toarray()
X_array

#We want to access the actual nucleobase sequence fragments of the 2-5-mer
feature_names = cv.get_feature_names()

#PART 3: Spliting the data set
#We will devide the data set to three parts. Train (≈60%), validation(≈20%) and test(≈20%)
from sklearn.model_selection import train_test_split
X_train, X_test, y_train, y_test = train_test_split(X, 
                                                    y, 
                                                    test_size = 0.2, 
                                                    random_state=1)

X_train, X_val, y_train, y_val = train_test_split(X_train, y_train, test_size=0.2, random_state=1)

#Sanity check: The ratio of each group to the total
print('Train:',X_train.shape[0]/df.shape[0])
print('Validation:',X_val.shape[0]/df.shape[0])
print('Validation:',X_test.shape[0]/df.shape[0])

#Check the shape of the Train group
X_train.shape

#PART 4: Creating the Model
#For our data set we will use Random Forest Classifier
from sklearn.ensemble import RandomForestClassifier

#Create a Gaussian Classifier
clf = RandomForestClassifier(n_estimators=100 , random_state=43)
clf.fit(X_train,y_train)

#We trained the model and we want check the accuracy of the model's prediction
y_pred = clf.predict(X_val)
from sklearn import metrics

print("Accuracy:",metrics.accuracy_score(y_val, y_pred))

#PART 5: Investigating the performance of the classification model by three methods:
# 1) Confusion Matrix   2) Roc Curve   3)Classification Report

#1) Confusion Matrix : 
from sklearn.metrics import plot_confusion_matrix
plot_confusion_matrix(clf, X_val, y_val, values_format = '')

#2) ROC (receiver operating characteristic) Curve:
#We can use different thresholds for classification. ROC curve summarizes all of the confusion matrices that each threshold produced
from sklearn.metrics import plot_roc_curve
plot_roc_curve(clf, X_val, y_val)

#3) Classification Report:
from sklearn.metrics import classification_report
print(classification_report(y_val, y_pred))

#PART 6: Feature Importance
#We want to investigate which 2-5-mers (sequence fragments) play a more important role in our model 
feature_imp = pd.Series(clf.feature_importances_).sort_values(ascending=False)
feature_imp

#Instead of the indexes we would like to see the actual sequence fragments
#We need to make a data frame where each fragments is assigned to it's corresponding feature importance
dic_feature_imp = {'feature_name':np.array(feature_names)[feature_imp.index], 'feature_imp': feature_imp} 
df_feature_imp = pd.DataFrame(dic_feature_imp)
df_feature_imp

#Prepare the data frame for ploting the feature importance 
#Importing the libraries 
import seaborn as sns 
import matplotlib.pyplot as plt

#Creating a data frame with the N-Gram occurences and the sequence classes
df_plot = pd.DataFrame(X_train.toarray(), columns = feature_names)

#Regarding blox plot visual limitations we can not plot all the feature importances
#We will use the 20 most important features for observation
nGramSum = df_plot.sum()
nGramSum = nGramSum.sort_values( ascending=False)
nGramTop = pd.DataFrame(df_plot[nGramSum.index[:20]])
nGramTop['class'] = y_train.values

#Check the new data frame
nGramTop

#We can continue now with melting the data and ploting it
meltNGram = pd.melt(nGramTop, id_vars='class')

#Ploting the data
fig, ax = plt.subplots(figsize=(12,9))
sns.boxplot(x='variable', y='value', hue='class', data=meltNGram)

"""SP1 Transcription factors bind to GC rich motifs. Results from the blox plot also indicates that binding sites have higher occurence of G or C N-mers. Therefore our model is efficiently predicting our binding sites."""

#PART 7: Applying the model to Test group
#The Test group is the last fraction of the data frame to apply the model and is a representation of our model effeciency
y_pred_test = clf.predict(X_test)
print("Accuracy:",metrics.accuracy_score(y_test, y_pred_test))

plot_confusion_matrix(clf, X_val, y_val, values_format = '')

